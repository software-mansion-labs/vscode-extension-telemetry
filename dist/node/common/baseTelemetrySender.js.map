{"version":3,"file":"baseTelemetrySender.js","sourceRoot":"","sources":["../../../src/common/baseTelemetrySender.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport type { TelemetrySender } from \"vscode\";\nimport { SenderData } from \"./baseTelemetryReporter\";\n\nexport interface BaseTelemetryClient {\n\tlogEvent(eventName: string, data?: SenderData): void;\n\tflush(): Promise<void>;\n\tdispose(): Promise<void>;\n}\n\nexport interface ILazyTelemetrySender extends TelemetrySender {\n\tinstantiateSender(): void\n\tdispose(): Promise<void>;\n}\n\nenum InstantiationStatus {\n\tNOT_INSTANTIATED,\n\tINSTANTIATING,\n\tINSTANTIATED,\n}\n\nexport class BaseTelemetrySender implements ILazyTelemetrySender {\n\t// Whether or not the client has been instantiated\n\tprivate _instantiationStatus: InstantiationStatus = InstantiationStatus.NOT_INSTANTIATED;\n\tprivate _telemetryClient: BaseTelemetryClient | undefined;\n\n\t// Queues used to store events until the sender is ready\n\tprivate _eventQueue: Array<{ eventName: string, data: SenderData | undefined }> = [];\n\tprivate _exceptionQueue: Array<{ exception: Error, data: SenderData | undefined }> = [];\n\n\t// Necessary information to create a telemetry client\n\tprivate _clientFactory: (key: string) => Promise<BaseTelemetryClient>;\n\tprivate _key: string;\n\n\tconstructor(\n\t\tkey: string,\n\t\tclientFactory: (key: string) => Promise<BaseTelemetryClient>,\n\t) {\n\t\tthis._clientFactory = clientFactory;\n\t\tthis._key = key;\n\t}\n\n\t/**\n\t * Sends the event to the passed in telemetry client\n\t * The sender does no telemetry level checks as those are done by the reporter.\n\t * @param eventName The name of the event to log\n\t * @param data The data contanied in the event\n\t */\n\tsendEventData(eventName: string, data?: SenderData): void {\n\t\tif (!this._telemetryClient) {\n\t\t\tif (this._instantiationStatus !== InstantiationStatus.INSTANTIATED) {\n\t\t\t\tthis._eventQueue.push({ eventName, data });\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis._telemetryClient.logEvent(eventName, data);\n\t}\n\n\t/**\n\t * Sends an exception to the passed in telemetry client\n\t * The sender does no telemetry level checks as those are done by the reporter.\n\t * @param exception The exception to collect\n\t * @param data Data associated with the exception\n\t */\n\tsendErrorData(exception: Error, data?: SenderData | Record<string, any>): void {\n\t\tif (!this._telemetryClient) {\n\t\t\tif (this._instantiationStatus !== InstantiationStatus.INSTANTIATED) {\n\t\t\t\tthis._exceptionQueue.push({ exception, data });\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tconst errorData = { stack: exception.stack, message: exception.message, name: exception.name };\n\t\tif (data) {\n\t\t\tconst errorProperties = data.properties || data;\n\t\t\tdata.properties = { ...errorProperties, ...errorData };\n\t\t} else {\n\t\t\tdata = { properties: errorData };\n\t\t}\n\t\tthis._telemetryClient.logEvent(\"unhandlederror\", data);\n\t}\n\n\t/**\n\t * Flushes the buffered telemetry data\n\t */\n\tasync flush(): Promise<void> {\n\t\treturn this._telemetryClient?.flush();\n\t}\n\n\tasync dispose(): Promise<void> {\n\t\tif (this._telemetryClient) {\n\t\t\tawait this._telemetryClient.dispose();\n\t\t\tthis._telemetryClient = undefined;\n\t\t}\n\t\treturn;\n\t}\n\n\t/**\n\t * Flushes the queued events that existed before the client was instantiated\n\t */\n\tprivate _flushQueues(): void {\n\t\tthis._eventQueue.forEach(({ eventName, data }) => this.sendEventData(eventName, data));\n\t\tthis._eventQueue = [];\n\t\tthis._exceptionQueue.forEach(({ exception, data }) => this.sendErrorData(exception, data));\n\t\tthis._exceptionQueue = [];\n\t}\n\n\t/**\n\t * Instantiates the telemetry client to make the sender \"active\"\n\t */\n\tinstantiateSender(): void {\n\t\tif (this._instantiationStatus !== InstantiationStatus.NOT_INSTANTIATED) {\n\t\t\treturn;\n\t\t}\n\t\tthis._instantiationStatus = InstantiationStatus.INSTANTIATING;\n\t\t// Call the client factory to get the client and then let it know it's instatntiated\n\t\tthis._clientFactory(this._key).then(client => {\n\t\t\tthis._telemetryClient = client;\n\t\t\tthis._instantiationStatus = InstantiationStatus.INSTANTIATED;\n\t\t\tthis._flushQueues();\n\t\t}).catch(err => {\n\t\t\tconsole.error(err);\n\t\t\t// If it failed to instntiate, then we don't want to try again.\n\t\t\t// So we mark it as instantiated. See #94\n\t\t\tthis._instantiationStatus = InstantiationStatus.INSTANTIATED;\n\t\t});\n\t}\n}\n"]}